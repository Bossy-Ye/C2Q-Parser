code_snippet,labels
"""# Python code\nimport networkx as nx\n\ndef priority_based_mis(G):\n    independent_set = set()\n    remaining_nodes = sorted(G.nodes(), key=lambda x: (G.degree(x), x))\n    while remaining_nodes:\n        node = remaining_nodes.pop(0)\n        independent_set.add(node)\n        neighbors = set(G.neighbors(node))\n        remaining_nodes = [n for n in remaining_nodes if n not in neighbors]\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nindependent_set = priority_based_mis(G)\nprint(f""Maximal Independent Set: {independent_set}"")""",1
"""# Python code\nimport networkx as nx\n\ndef greedy_degree_mis(G):\n    independent_set = set()\n    remaining_nodes = sorted(G.nodes(), key=lambda x: G.degree(x), reverse=True)\n    while remaining_nodes:\n        node = remaining_nodes.pop(0)\n        independent_set.add(node)\n        neighbors = set(G.neighbors(node))\n        remaining_nodes = [n for n in remaining_nodes if n not in neighbors]\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4)])\nindependent_set = greedy_degree_mis(G)\nprint(f""Maximal Independent Set: {independent_set}"")""",1
"""# Python code\nimport networkx as nx\n\ndef recursive_heuristic_mis(G, independent_set=None, remaining_nodes=None):\n    if independent_set is None:\n        independent_set = set()\n    if remaining_nodes is None:\n        remaining_nodes = set(G.nodes())\n    if not remaining_nodes:\n        return independent_set\n    node = min(remaining_nodes, key=lambda x: G.degree(x))\n    neighbors = set(G.neighbors(node))\n    new_set = independent_set | {node}\n    return recursive_heuristic_mis(G, new_set, remaining_nodes - neighbors)\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4)])\nindependent_set = recursive_heuristic_mis(G)\nprint(f""Maximal Independent Set: {independent_set}"")""",1
"""# Python code\nimport networkx as nx\n\ndef depth_first_mis(G):\n    independent_set = set()\n    visited_nodes = set()\n    def dfs(node):\n        if node not in visited_nodes:\n            visited_nodes.add(node)\n            independent_set.add(node)\n            for neighbor in G.neighbors(node):\n                visited_nodes.add(neighbor)\n    for start_node in G.nodes():\n        dfs(start_node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(1, 2), (2, 3), (3, 5), (5, 6), (6, 1)])\nresult_set = depth_first_mis(G)\nprint(f""Maximal Independent Set: {result_set}"")""",1
"""# Python code\nimport networkx as nx\nimport random\n\ndef shuffled_greedy_mis(G):\n    independent_set = set()\n    nodes = list(G.nodes())\n    random.shuffle(nodes)\n    for node in nodes:\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 2), (2, 3), (3, 5), (5, 6), (6, 0)])\nmis_set = shuffled_greedy_mis(G)\nprint(f""Maximal Independent Set: {mis_set}"")""",1
"""# Python code\nimport networkx as nx\nimport random\n\ndef random_degree_priority_mis(G):\n    independent_set = set()\n    nodes = sorted(G.nodes(), key=lambda n: G.degree(n), reverse=True)\n    random.shuffle(nodes)\n    while nodes:\n        node = nodes.pop(0)\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(1, 2), (2, 4), (4, 5), (5, 3), (3, 1)])\nmis_set = random_degree_priority_mis(G)\nprint(f""Maximal Independent Set: {mis_set}"")"" ",1
"""# Python code\nimport networkx as nx\nimport random\n\ndef random_degree_priority_mis(G):\n    independent_set = set()\n    nodes = sorted(G.nodes(), key=lambda n: G.degree(n), reverse=True)\n    random.shuffle(nodes)\n    while nodes:\n        node = nodes.pop(0)\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(1, 2), (2, 4), (4, 5), (5, 3), (3, 1)])\nmis_set = random_degree_priority_mis(G)\nprint(f""Maximal Independent Set: {mis_set}"")"" ",1
"""import networkx as nx\n\ndef recursive_mis(graph, current_set=None, remaining=None):\n    if current_set is None:\n        current_set = set()\n    if remaining is None:\n        remaining = set(graph.nodes())\n    if not remaining:\n        return current_set\n    node = remaining.pop()\n    neighbors = set(graph.neighbors(node))\n    new_set = current_set | {node}\n    return recursive_mis(graph, new_set, remaining - neighbors)\n\ngraph = nx.Graph()\ngraph.add_edges_from([(0, 2), (2, 3), (3, 1), (1, 0)])\nresult = recursive_mis(graph)\nprint(f""Maximal Independent Set: {result}"")"" ",1
"""# Python code\nimport networkx as nx\nimport random\n\ndef randomized_maxcut_random(G, iterations=500):\n    max_cut_value = 0\n    best_partition = None\n    nodes = list(G.nodes())\n    for _ in range(iterations):\n        partition_A = set(random.sample(nodes, len(nodes) // 2))\n        partition_B = set(nodes) - partition_A\n        cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n        if cut_value > max_cut_value:\n            max_cut_value = cut_value\n            best_partition = (partition_A, partition_B)\n    return max_cut_value, best_partition\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 4), (4, 3), (3, 0)])\nmax_cut, best_part = randomized_maxcut_random(G)\nprint(f""Maximum Cut: {max_cut}"")\nprint(f""Best Partition: {best_part}"")"" ",0
"""# Python code\nimport networkx as nx\n\ndef greedy_maxcut_simple(G):\n    partition_A = set()\n    partition_B = set(G.nodes())\n    for node in G.nodes():\n        if sum(1 for neighbor in G.neighbors(node) if neighbor in partition_A) > sum(1 for neighbor in G.neighbors(node) if neighbor in partition_B):\n            partition_B.add(node)\n        else:\n            partition_A.add(node)\n    max_cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n    return max_cut_value, partition_A, partition_B\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncut_value, part_A, part_B = greedy_maxcut_simple(G)\nprint(f""Maximum Cut Value: {cut_value}"")"" ",0
"# Python code\nimport networkx as nx\n\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nresult = maximum_cut(G)\nprint(result)",1
"""import networkx as nx\nimport random\n\ndef randomized_maxcut(G, iterations=1000):\n    max_cut_value = 0\n    best_partition = None\n    nodes = list(G.nodes())\n    for _ in range(iterations):\n        partition_A = set(random.sample(nodes, len(nodes) // 2))\n        partition_B = set(nodes) - partition_A\n        cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n    return max_cut_value, best_partition\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nmax_cut_value, best_partition = randomized_maxcut(G)\nprint(f\""Maximum cut value: {max_cut_value}\"")\nprint(f\""Best partition: {best_partition}\"")""",1
"""# Python code\nimport networkx as nx\n\ndef independent_set(G):\n    independent_set = set()\n    for node in G.nodes():\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nresult = independent_set(G)\nprint(f\""Independent Set: {result}\"")""",0
"""# Python code\nimport networkx as nx\n\ndef maximum_cut_randomized(G):\n    # Randomized approach for solving Maximum Cut\n    import random\n    partition_A = set(random.sample(G.nodes(), len(G.nodes()) // 2))\n    partition_B = set(G.nodes()) - partition_A\n    cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)])\ncut_value = maximum_cut_randomized(G)\nprint(f\""Maximum Cut Value: {cut_value}\"")""",0
"""# Python code\nimport networkx as nx\n\ndef independent_set_heuristic(G):\n    # Use heuristic approach to find independent set\n    independent_set = set()\n    for node in G.nodes():\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 3), (3, 4), (4, 2)])\nresult = independent_set_heuristic(G)\nprint(f\""Independent Set: {result}\"")""",1
"""import networkx as nx\n\ndef max_cut_using_simulated_annealing(G):\n    # Simulated Annealing approach for Maximum Cut\n    import random, math\n    nodes = list(G.nodes())\n    curr_sol = set(random.sample(nodes, len(nodes) // 2))\n    best_sol = curr_sol\n    cut_val = calc_cut_value(G, curr_sol)\n    temp = 1000\n    while temp > 1:\n        new_sol = curr_sol.copy()\n        node = random.choice(list(new_sol))\n        new_sol.remove(node)\n        new_cut_val = calc_cut_value(G, new_sol)\n        if new_cut_val > cut_val or math.exp((new_cut_val - cut_val) / temp) > random.random():\n            curr_sol = new_sol\n            cut_val = new_cut_val\n            best_sol = curr_sol\n        temp *= 0.95\n    return cut_val, best_sol\n\ndef calc_cut_value(G, partition_A):\n    partition_B = set(G.nodes()) - partition_A\n    return sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 3), (3, 4), (4, 2)])\ncut_value, partition = max_cut_using_simulated_annealing(G)\n""",0
"""# Python code\nimport networkx as nx\n\ndef greedy_maximum_cut_algo(graph):\n    # Greedy solution to solve the Maximum Cut\n    A = set()\n    B = set(graph.nodes())\n    for n in graph.nodes():\n        if sum(1 for neighbor in graph.neighbors(n) if neighbor in A) > sum(1 for neighbor in graph.neighbors(n) if neighbor in B):\n            B.add(n)\n        else:\n            A.add(n)\n    cut_value = sum(1 for u, v in graph.edges() if (u in A and v in B) or (u in B and v in A))\n    return cut_value, A, B\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncut_value, A, B = greedy_maximum_cut_algo(G)\nprint(f\""Max Cut: {cut_value}\"")""",0
"""# Python code\nimport networkx as nx\n\ndef maximal_independent_set_dfs(graph):\n    # DFS approach to find maximal independent set\n    i_set = set()\n    visited = set()\n    def dfs(node):\n        if node not in visited:\n            visited.add(node)\n            i_set.add(node)\n            for neighbor in graph.neighbors(node):\n                visited.add(neighbor)\n    for start_node in graph.nodes():\n        dfs(start_node)\n    return i_set\n\nG = nx.Graph()\nG.add_edges_from([(1, 2), (2, 3), (3, 5), (5, 0)])\nindependent_set = maximal_independent_set_dfs(G)\nprint(f\""Maximal Independent Set: {independent_set}\"")""",1
"""# Python code\nimport networkx as nx\n\ndef randomized_independent_set_algorithm(G):\n    # Use randomized approach to find independent set\n    import random\n    independent_set = set()\n    remaining_nodes = list(G.nodes())\n    random.shuffle(remaining_nodes)\n    for node in remaining_nodes:\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nresult = randomized_independent_set_algorithm(G)\nprint(f\""Independent Set: {result}\"")""",1
"""import networkx as nx\nfrom itertools import permutations\n\ndef tsp_brute_force(graph):\n    # Brute-force solution for TSP\n    nodes = list(graph.nodes())\n    min_cost = float('inf')\n    best_route = None\n    for route in permutations(nodes):\n        cost = sum(graph[route[i]][route[i+1]]['weight'] for i in range(len(route) - 1)) + graph[route[-1]][route[0]]['weight']\n        if cost < min_cost:\n            min_cost = cost\n            best_route = route\n    return min_cost, best_route\n\nG = nx.Graph()\nG.add_weighted_edges_from([(0, 1, 8), (1, 2, 12), (2, 3, 15), (3, 0, 9)])\nmin_cost, route = tsp_brute_force(G)",2
"""# Python code\nimport networkx as nx\nimport random\n\ndef tsp_greedy(graph):\n    # Greedy algorithm for TSP\n    start_node = random.choice(list(graph.nodes()))\n    unvisited = set(graph.nodes())\n    unvisited.remove(start_node)\n    route = [start_node]\n    current_node = start_node\n    total_cost = 0\n    while unvisited:\n        next_node = min(unvisited, key=lambda node: graph[current_node][node]['weight'])\n        total_cost += graph[current_node][next_node]['weight']\n        route.append(next_node)\n        unvisited.remove(next_node)\n        current_node = next_node\n    total_cost += graph[route[-1]][route[0]]['weight']\n    return total_cost, route\n\nG = nx.Graph()\nG.add_weighted_edges_from([(0, 1, 11), (1, 2, 9), (2, 3, 14), (3, 0, 12)])\ncost, route = tsp_greedy(G)",2
"""def maximum_cut_heuristic(n, edges):\n    set_A, set_B = set(), set(range(n))\n    while set_B:\n        node = set_B.pop()\n        if sum(1 for u, v in edges if u == node and v in set_A) > sum(1 for u, v in edges if u == node and v in set_B):\n            set_A.add(node)\n        else:\n            set_B.add(node)\n    cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n    return cut_value, set_A, set_B\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, set_A, set_B = maximum_cut_heuristic(4, edges)""",0
"""def maximal_independent_set_approx(n, edges):\n    independent_set = set()\n    nodes = set(range(n))\n    while nodes:\n        node = nodes.pop()\n        independent_set.add(node)\n        neighbors = {v for u, v in edges if u == node}\n        nodes -= neighbors\n    return independent_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set = maximal_independent_set_approx(4, edges)\nprint(f\""Maximal Independent Set: {independent_set}\"")""",1
"""def tsp_simulated_annealing(cost_matrix):\n    import random, math\n    n = len(cost_matrix)\n    current_route = list(range(n))\n    random.shuffle(current_route)\n    current_cost = sum(cost_matrix[current_route[i]][current_route[i+1]] for i in range(n-1)) + cost_matrix[current_route[-1]][current_route[0]]\n    temp = 1000\n    cooling_rate = 0.95\n    while temp > 1:\n        new_route = current_route[:]\n        i, j = random.sample(range(n), 2)\n        new_route[i], new_route[j] = new_route[j], new_route[i]\n        new_cost = sum(cost_matrix[new_route[i]][new_route[i+1]] for i in range(n-1)) + cost_matrix[new_route[-1]][new_route[0]]\n        if new_cost < current_cost or math.exp((current_cost - new_cost) / temp) > random.random():\n            current_route = new_route\n            current_cost = new_cost\n        temp *= cooling_rate\n    return current_cost, current_route\n\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = tsp_simulated_annealing(cost_matrix)""",2
"def maximum_cut_quick(edges, n):\n    set_A, set_B = set(), set(range(n))\n    for u, v in edges:\n        if len(set_A) < len(set_B):\n            set_A.add(u)\n        else:\n            set_B.add(v)\n    return sum(1 for u, v in edges if (u in set_A and v in set_B)), set_A, set_B",0
"def independent_set_quick(n, edges):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set",1
"def tsp_approx(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route",2
"import networkx as nx\n\ndef maximum_cut_greedy_networkx(G):\n    set_A, set_B = set(), set(G.nodes)\n    for node in G.nodes:\n        if sum(1 for neighbor in G.neighbors(node) if neighbor in set_A) > sum(1 for neighbor in G.neighbors(node) if neighbor in set_B):\n            set_B.add(node)\n        else:\n            set_A.add(node)\n    cut_value = sum(1 for u, v in G.edges if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n    return cut_value, set_A, set_B\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nmaximum_cut_greedy_networkx(G)",0
"def maximum_cut_randomized(edges, n):\n    import random\n    set_A, set_B = set(), set()\n    for i in range(n):\n        if random.random() > 0.5:\n            set_A.add(i)\n        else:\n            set_B.add(i)\n    return sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in set_B and v in set_A)), set_A, set_B\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nmaximum_cut_randomized(edges, 4)",0
"import networkx as nx\n\ndef independent_set_greedy_networkx(G):\n    independent_set = set()\n    for node in G.nodes:\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nindependent_set_greedy_networkx(G)",1
"def independent_set_random(n, edges):\n    from random import shuffle\n    nodes = list(range(n))\n    shuffle(nodes)\n    independent_set = set()\n    for node in nodes:\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set_random(n, edges)",1
"import networkx as nx\n\ndef tsp_brute_force_networkx(G):\n    from itertools import permutations\n    best_cost = float('inf')\n    best_route = None\n    for route in permutations(G.nodes):\n        cost = sum(G[route[i]][route[i+1]]['weight'] for i in range(len(route) - 1)) + G[route[-1]][route[0]]['weight']\n        if cost < best_cost:\n            best_cost = cost\n            best_route = route\n    return best_cost, best_route\n\nG = nx.Graph()\nG.add_weighted_edges_from([(0, 1, 10), (1, 2, 15), (2, 3, 20), (3, 0, 25)])\ntsp_brute_force_networkx(G)",2
"def tsp_greedy(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ntsp_greedy(cost_matrix)",2
"import networkx as nx\n\ndef tsp_nearest_neighbor_networkx(G):\n    visited = [False] * len(G)\n    route = [0]\n    visited[0] = True\n    total_cost = 0\n    current = 0\n    for _ in range(len(G) - 1):\n        next_city = min((city for city in range(len(G)) if not visited[city]), key=lambda city: G[current][city]['weight'])\n        total_cost += G[current][next_city]['weight']\n        route.append(next_city)\n        visited[next_city] = True\n        current = next_city\n    total_cost += G[route[-1]][route[0]]['weight']\n    return total_cost, route\n\nG = nx.Graph()\nG.add_weighted_edges_from([(0, 1, 10), (1, 2, 15), (2, 3, 20), (3, 0, 25)])\ntsp_nearest_neighbor_networkx(G)",2
"def independent_set_degree_heuristic(n, edges):\n    degree = {i: sum(1 for u, v in edges if u == i or v == i) for i in range(n)}\n    independent_set = set()\n    for node in sorted(range(n), key=lambda x: degree[x]):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set_degree_heuristic(n, edges)",1
"def clique_brute_force(n, edges):\n    from itertools import combinations\n    max_clique = []\n    for k in range(2, n+1):\n        for subset in combinations(range(n), k):\n            if all((u, v) in edges or (v, u) in edges for u in subset for v in subset if u != v):\n                if len(subset) > len(max_clique):\n                    max_clique = subset\n    return max_clique",3
"import networkx as nx\n\ndef clique_networkx_greedy(G):\n    clique = set()\n    for node in G.nodes():\n        if all(neighbor in clique or (G.has_edge(node, neighbor)) for neighbor in G.neighbors(node)):\n            clique.add(node)\n    return clique\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)])\nclique_networkx_greedy(G)",3
"def clique_greedy_degree_heuristic(n, edges):\n    degree = {i: sum(1 for u, v in edges if u == i or v == i) for i in range(n)}\n    clique = set()\n    for node in sorted(range(n), key=lambda x: degree[x], reverse=True):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nclique_greedy_degree_heuristic(4, edges)",3
"def clique_bitmask(n, edges):\n    max_clique = []\n    for mask in range(1 << n):\n        subset = [i for i in range(n) if mask & (1 << i)]\n        if all((u, v) in edges or (v, u) in edges for u in subset for v in subset if u != v):\n            if len(subset) > len(max_clique):\n                max_clique = subset\n    return max_clique\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nclique_bitmask(4, edges)",3
"import networkx as nx\n\ndef clique_networkx_backtracking(G):\n    def is_clique(nodes):\n        return all(G.has_edge(u, v) for u in nodes for v in nodes if u != v)\n    def backtrack(node, current_clique):\n        if node == len(G.nodes):\n            return current_clique\n        if is_clique(current_clique + [node]):\n            with_node = backtrack(node + 1, current_clique + [node])\n            without_node = backtrack(node + 1, current_clique)\n            return max(with_node, without_node, key=len)\n        return backtrack(node + 1, current_clique)\n    return backtrack(0, [])\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nclique_networkx_backtracking(G)",3
"def clique_approximate(n, edges):\n    clique = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nclique_approximate(4, edges)",3
"def clique_backtracking(n, edges):\n    def is_clique(nodes):\n        return all((u, v) in edges or (v, u) in edges for u in nodes for v in nodes if u != v)\n    def backtrack(node, current_clique):\n        if node == n:\n            return current_clique\n        if is_clique(current_clique + [node]):\n            with_node = backtrack(node + 1, current_clique + [node])\n            without_node = backtrack(node + 1, current_clique)\n            return max(with_node, without_node, key=len)\n        return backtrack(node + 1, current_clique)\n    return backtrack(0, [])\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nclique_backtracking(4, edges)",3
"import networkx as nx\n\ndef clique_networkx_brute_force(G):\n    from itertools import combinations\n    max_clique = []\n    nodes = list(G.nodes())\n    for k in range(2, len(nodes) + 1):\n        for subset in combinations(nodes, k):\n            if G.subgraph(subset).number_of_edges() == len(subset) * (len(subset) - 1) // 2:\n                if len(subset) > len(max_clique):\n                    max_clique = subset\n    return max_clique\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nclique_networkx_brute_force(G)",3
"def clique_randomized(n, edges):\n    import random\n    nodes = list(range(n))\n    random.shuffle(nodes)\n    clique = set()\n    for node in nodes:\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nclique_randomized(4, edges)",3
"def clique_greedy(n, edges):\n    clique = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nclique_greedy(4, edges)",3
"def kcoloring_largest_degree_first(n, edges, k):\n    degree = {i: sum(1 for u, v in edges if u == i or v == i) for i in range(n)}\n    colors = [-1] * n\n    for node in sorted(range(n), key=lambda x: degree[x], reverse=True):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_largest_degree_first(4, edges, 3)",4
"import random\n\ndef kcoloring_random_walk(n, edges, k):\n    colors = [-1] * n\n    nodes = list(range(n))\n    random.shuffle(nodes)\n    for node in nodes:\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = random.choice(list(available_colors))\n    return colors\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_random_walk(4, edges, 3)",4
"import networkx as nx\n\ndef kcoloring_networkx_largest_degree(G, k):\n    degree = {i: len(list(G.neighbors(i))) for i in G.nodes}\n    colors = {}\n    for node in sorted(G.nodes(), key=lambda x: degree[x], reverse=True):\n        available_colors = set(range(k)) - {colors[neighbor] for neighbor in G.neighbors(node) if neighbor in colors}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nkcoloring_networkx_largest_degree(G, 3)",4
"def kcoloring_greedy_recursive(n, edges, k):\n    colors = [-1] * n\n    def assign_color(node):\n        if node == n:\n            return colors\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n            return assign_color(node + 1)\n        return None\n    return assign_color(0)\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_greedy_recursive(4, edges, 3)",4
"import random\n\ndef kcoloring_simulated_annealing(n, edges, k, max_steps=1000):\n    colors = [random.choice(range(k)) for _ in range(n)]\n    temperature = 1000\n    def count_conflicts():\n        return sum(1 for u, v in edges if colors[u] == colors[v])\n    for _ in range(max_steps):\n        if count_conflicts() == 0:\n            return colors\n        node = random.choice(range(n))\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            new_color = random.choice(list(available_colors))\n            current_conflicts = count_conflicts()\n            colors[node] = new_color\n            if count_conflicts() >= current_conflicts and random.random() > (1.0 / temperature):\n                colors[node] = new_color  # Revert to previous\n        temperature *= 0.95\n    return None\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_simulated_annealing(4, edges, 3)",4
"import networkx as nx\n\ndef kcoloring_networkx_simulated_annealing(G, k):\n    import random, math\n    colors = {node: random.choice(range(k)) for node in G.nodes()}\n    temperature = 1000\n    def count_conflicts():\n        return sum(1 for node in G.nodes() for neighbor in G.neighbors(node) if colors[node] == colors[neighbor])\n    for _ in range(1000):\n        if count_conflicts() == 0:\n            return colors\n        node = random.choice(list(G.nodes()))\n        available_colors = set(range(k)) - {colors[neighbor] for neighbor in G.neighbors(node)}\n        if available_colors:\n            new_color = random.choice(list(available_colors))\n            current_conflicts = count_conflicts()\n            colors[node] = new_color\n            if count_conflicts() >= current_conflicts and random.random() > (1.0 / temperature):\n                colors[node] = new_color  # Revert to previous\n        temperature *= 0.95\n    return None\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nkcoloring_networkx_simulated_annealing(G, 3)",4
"def kcoloring_backtracking_revised(n, edges, k):\n    def is_valid_coloring(node, color, colors):\n        return all(colors[neighbor] != color for u, v in edges if u == node for neighbor in [v])\n    def backtrack(node, colors):\n        if node == n:\n            return colors\n        for color in range(k):\n            if is_valid_coloring(node, color, colors):\n                colors[node] = color\n                result = backtrack(node + 1, colors)\n                if result is not None:\n                    return result\n                colors[node] = -1\n        return None\n    return backtrack(0, [-1] * n)\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_backtracking_revised(4, edges, 3)",4
"import random\n\ndef kcoloring_random_restarts(n, edges, k, max_restarts=10):\n    def random_coloring():\n        colors = [-1] * n\n        nodes = list(range(n))\n        random.shuffle(nodes)\n        for node in nodes:\n            available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n            if available_colors:\n                colors[node] = random.choice(list(available_colors))\n        return colors\n    for _ in range(max_restarts):\n        colors = random_coloring()\n        if all(colors[node] != colors[neighbor] for u, v in edges for neighbor in [v]):\n            return colors\n    return None\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_random_restarts(4, edges, 3)",4
"import networkx as nx\n\ndef kcoloring_networkx_greedy_optimized(G, k):\n    degree = {i: len(list(G.neighbors(i))) for i in G.nodes()}\n    colors = {}\n    for node in sorted(G.nodes(), key=lambda x: degree[x], reverse=True):\n        available_colors = set(range(k)) - {colors[neighbor] for neighbor in G.neighbors(node) if neighbor in colors}\n        if available_colors:\n            colors[node] = min(available_colors)\n        else:\n            return None\n    return colors\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nkcoloring_networkx_greedy_optimized(G, 3)",4
"def kcoloring_custom_order(n, edges, k):\n    custom_order = [0, 3, 1, 2]  # Some arbitrary custom order\n    colors = [-1] * n\n    for node in custom_order:\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_custom_order(4, edges, 3)",4