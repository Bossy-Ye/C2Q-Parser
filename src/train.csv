code_snippet,labels
"# Python code\nimport networkx as nx\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)])\nresult = maximum_cut(G)\nprint(result)",0
"# Python code\nimport networkx as nx\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)])\nresult = maximum_cut(G)\nprint(result)",0
"import networkx as nx\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (1, 3), (2, 4), (3, 4), (4, 5)])\nresult = maximum_cut(G)\nprint(result)",0
"# Python code\nimport networkx as nx\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (0, 2), (0, 3), (1, 3), (2, 3), (1, 4)])\nresult = maximum_cut(G)\nprint(result)",0
"import networkx as nx\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nresult = maximum_cut(G)\nprint(result)",0
"import networkx as nx\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (0, 2), (2, 3), (3, 4)])\nresult = maximum_cut(G)\nprint(result)",0
"# Python code\nimport networkx as nx\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 3), (3, 4), (0, 2), (2, 4)])\nresult = maximum_cut(G)\nprint(result)",0
"# Python code\nimport networkx as nx\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(1, 2), (2, 3), (3, 4), (1, 4), (2, 5)])\nresult = maximum_cut(G)\nprint(result)",0
"# Python code\nimport itertools\nimport networkx as nx\n\ndef maxcut_bruteforce(G):\n    max_cut_value = 0\n    best_partition = None\n    nodes = list(G.nodes())\n    for i in range(1, len(nodes)):\n        for cut in itertools.combinations(nodes, i):\n            partition_A = set(cut)\n            partition_B = set(nodes) - partition_A\n            cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n            if cut_value > max_cut_value:\n                max_cut_value = cut_value\n                best_partition = (partition_A, partition_B)\n    return max_cut_value, best_partition\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (0, 2), (1, 2), (1, 3), (2, 3), (3, 4), (4, 5)])\nmax_cut_value, best_partition = maxcut_bruteforce(G)\nprint(f""Maximum cut value: {max_cut_value}"")\nprint(f""Best partition: {best_partition}"")",0
"# Python code\nimport networkx as nx\nimport random\n\ndef randomized_maxcut(G, iterations=1000):\n    max_cut_value = 0\n    best_partition = None\n    nodes = list(G.nodes())\n    for _ in range(iterations):\n        partition_A = set(random.sample(nodes, len(nodes) // 2))\n        partition_B = set(nodes) - partition_A\n        cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n        if cut_value > max_cut_value:\n            max_cut_value = cut_value\n            best_partition = (partition_A, partition_B)\n    return max_cut_value, best_partition\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nmax_cut_value, best_partition = randomized_maxcut(G)\nprint(f""Maximum cut value: {max_cut_value}"")\nprint(f""Best partition: {best_partition}"")",0
"import itertools\nimport networkx as nx\n\ndef maxcut_bruteforce(G):\n    max_cut_value = 0\n    best_partition = None\n    nodes = list(G.nodes())\n    for i in range(1, len(nodes)):\n        for cut in itertools.combinations(nodes, i):\n            partition_A = set(cut)\n            partition_B = set(nodes) - partition_A\n            cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n            if cut_value > max_cut_value:\n                max_cut_value = cut_value\n                best_partition = (partition_A, partition_B)\n    return max_cut_value, best_partition\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (0, 2), (1, 2), (1, 3), (2, 3), (3, 4), (4, 5)])\nmax_cut_value, best_partition = maxcut_bruteforce(G)\nprint(f""Maximum cut value: {max_cut_value}"")\nprint(f""Best partition: {best_partition}"")",0
"# Python code\nimport networkx as nx\nimport random\n\ndef randomized_maxcut(G, iterations=1000):\n    max_cut_value = 0\n    best_partition = None\n    nodes = list(G.nodes())\n    for _ in range(iterations):\n        partition_A = set(random.sample(nodes, len(nodes) // 2))\n        partition_B = set(nodes) - partition_A\n        cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n        if cut_value > max_cut_value:\n            max_cut_value = cut_value\n            best_partition = (partition_A, partition_B)\n    return max_cut_value, best_partition\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nmax_cut_value, best_partition = randomized_maxcut(G)\nprint(f""Maximum cut value: {max_cut_value}"")\nprint(f""Best partition: {best_partition}"")",0
"import networkx as nx\nimport random\n\ndef randomized_maximal_independent_set(G):\n    independent_set = set()\n    nodes = list(G.nodes())\n    random.shuffle(nodes)\n    while nodes:\n        node = nodes.pop(0)\n        independent_set.add(node)\n        for neighbor in G.neighbors(node):\n            if neighbor in nodes:\n                nodes.remove(neighbor)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)])\nindependent_set = randomized_maximal_independent_set(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"# Python code\nimport networkx as nx\n\ndef iterative_maximal_independent_set(G):\n    independent_set = set()\n    remaining_nodes = set(G.nodes())\n    while remaining_nodes:\n        node = remaining_nodes.pop()\n        independent_set.add(node)\n        neighbors = set(G.neighbors(node))\n        remaining_nodes -= neighbors\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4)])\nindependent_set = iterative_maximal_independent_set(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"import networkx as nx\n\ndef heuristic_maximal_independent_set(G):\n    independent_set = set()\n    remaining_nodes = sorted(G.nodes(), key=lambda x: G.degree(x), reverse=True)\n    while remaining_nodes:\n        node = remaining_nodes.pop(0)\n        independent_set.add(node)\n        neighbors = set(G.neighbors(node))\n        remaining_nodes = [n for n in remaining_nodes if n not in neighbors]\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)])\nindependent_set = heuristic_maximal_independent_set(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"# Python code\nimport networkx as nx\n\ndef backtrack_maximal_independent_set(G, remaining_nodes=None, independent_set=None):\n    if independent_set is None:\n        independent_set = set()\n    if remaining_nodes is None:\n        remaining_nodes = set(G.nodes())\n    if not remaining_nodes:\n        return independent_set\n    node = remaining_nodes.pop()\n    new_set = independent_set.copy()\n    new_set.add(node)\n    neighbors = set(G.neighbors(node))\n    return backtrack_maximal_independent_set(G, remaining_nodes - neighbors, new_set)\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nindependent_set = backtrack_maximal_independent_set(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"# Python code\nimport networkx as nx\n\ndef dfs_maximal_independent_set(G):\n    def dfs(node, visited, independent_set):\n        visited.add(node)\n        independent_set.add(node)\n        for neighbor in G.neighbors(node):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                for neighbor_of_neighbor in G.neighbors(neighbor):\n                    if neighbor_of_neighbor not in visited:\n                        dfs(neighbor_of_neighbor, visited, independent_set)\n    visited = set()\n    independent_set = set()\n    for node in G.nodes():\n        if node not in visited:\n            dfs(node, visited, independent_set)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nindependent_set = dfs_maximal_independent_set(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"import networkx as nx\n\ndef degree_based_maximal_independent_set(G):\n    independent_set = set()\n    remaining_nodes = sorted(G.nodes(), key=lambda x: G.degree(x))\n    while remaining_nodes:\n        node = remaining_nodes.pop(0)\n        independent_set.add(node)\n        neighbors = set(G.neighbors(node))\n        remaining_nodes = [n for n in remaining_nodes if n not in neighbors]\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)])\nindependent_set = degree_based_maximal_independent_set(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"import networkx as nx\n\ndef lexicographical_maximal_independent_set(G):\n    independent_set = set()\n    remaining_nodes = sorted(G.nodes())\n    while remaining_nodes:\n        node = remaining_nodes.pop(0)\n        independent_set.add(node)\n        neighbors = set(G.neighbors(node))\n        remaining_nodes = [n for n in remaining_nodes if n not in neighbors]\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nindependent_set = lexicographical_maximal_independent_set(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"# Python code\nimport networkx as nx\nfrom collections import deque\n\ndef bfs_maximal_independent_set(G):\n    independent_set = set()\n    visited = set()\n    queue = deque(G.nodes())\n    while queue:\n        node = queue.popleft()\n        if node not in visited:\n            independent_set.add(node)\n            visited.add(node)\n            for neighbor in G.neighbors(node):\n                visited.add(neighbor)\n                for n in G.neighbors(neighbor):\n                    if n not in visited and n not in queue:\n                        queue.append(n)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4)])\nindependent_set = bfs_maximal_independent_set(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"# Python code\nimport networkx as nx\n\ndef degree_first_mis(G):\n    independent_set = set()\n    remaining_nodes = sorted(G.nodes(), key=lambda x: G.degree(x), reverse=True)\n    while remaining_nodes:\n        node = remaining_nodes.pop(0)\n        independent_set.add(node)\n        neighbors = set(G.neighbors(node))\n        remaining_nodes = [n for n in remaining_nodes if n not in neighbors]\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4)])\nindependent_set = degree_first_mis(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"# Python code\nimport networkx as nx\nimport random\n\ndef randomized_greedy_mis(G):\n    independent_set = set()\n    remaining_nodes = sorted(G.nodes(), key=lambda x: G.degree(x))\n    random.shuffle(remaining_nodes)\n    while remaining_nodes:\n        node = remaining_nodes.pop(0)\n        independent_set.add(node)\n        neighbors = set(G.neighbors(node))\n        remaining_nodes = [n for n in remaining_nodes if n not in neighbors]\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4)])\nindependent_set = randomized_greedy_mis(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"# Python code\nimport networkx as nx\nimport random\n\ndef randomized_degree_maximal_independent_set(G):\n    independent_set = set()\n    remaining_nodes = sorted(G.nodes(), key=lambda x: G.degree(x))\n    random.shuffle(remaining_nodes)\n    while remaining_nodes:\n        node = remaining_nodes.pop(0)\n        independent_set.add(node)\n        neighbors = set(G.neighbors(node))\n        remaining_nodes = [n for n in remaining_nodes if n not in neighbors]\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nindependent_set = randomized_degree_maximal_independent_set(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"import networkx as nx\n\ndef greedy_mis_variation(graph):\n    independent_set = set()\n    remaining_nodes = sorted(graph.nodes(), key=lambda x: graph.degree(x), reverse=True)\n    while remaining_nodes:\n        n = remaining_nodes.pop(0)\n        independent_set.add(n)\n        neighbors = set(graph.neighbors(n))\n        remaining_nodes = [node for node in remaining_nodes if node not in neighbors]\n    return independent_set\n\ngraph = nx.Graph()\ngraph.add_edges_from([(0, 1), (1, 3), (3, 4), (4, 5), (5, 0)])\nmis_set = greedy_mis_variation(graph)\nprint(f""Maximal Independent Set: {mis_set}"")",1
"# Python code\nimport itertools\nimport networkx as nx\n\ndef brute_force_maxcut(G):\n    max_cut_value = 0\n    best_partition = None\n    nodes = list(G.nodes())\n    for i in range(1, len(nodes)):\n        for cut in itertools.combinations(nodes, i):\n            partition_A = set(cut)\n            partition_B = set(nodes) - partition_A\n            cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n            if cut_value > max_cut_value:\n                max_cut_value = cut_value\n                best_partition = (partition_A, partition_B)\n    return max_cut_value, best_partition\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncut_value, partition = brute_force_maxcut(G)\nprint(f""Maximum Cut Value: {cut_value}"")\nprint(f""Best Partition: {partition}"")",0
"import networkx as nx\n\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)])\nresult = maximum_cut(G)\nprint(result)",1
"# Python code\nimport networkx as nx\nimport random\n\ndef randomized_maxcut(G, iterations=1000):\n    max_cut_value = 0\n    best_partition = None\n    nodes = list(G.nodes())\n    for _ in range(iterations):\n        partition_A = set(random.sample(nodes, len(nodes) // 2))\n        partition_B = set(nodes) - partition_A\n        cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n        if cut_value > max_cut_value:\n            max_cut_value = cut_value\n            best_partition = (partition_A, partition_B)\n    return max_cut_value, best_partition\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nmax_cut_value, best_partition = randomized_maxcut(G)\nprint(f\""Maximum cut value: {max_cut_value}\"")\nprint(f\""Best partition: {best_partition}\"")",1
"""import networkx as nx\n\ndef maximum_cut(G):\n    # Calculate maximum cut value using a greedy algorithm\n    partition_A = set()\n    partition_B = set(G.nodes())\n    for node in G.nodes():\n        # Assign the node to partition based on neighbors\n        if sum(1 for neighbor in G.neighbors(node) if neighbor in partition_A) > sum(1 for neighbor in G.neighbors(node) if neighbor in partition_B):\n            partition_B.add(node)\n        else:\n            partition_A.add(node)\n    # Calculate the maximum cut\n    cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncut_value = maximum_cut(G)\nprint(f\""Maximum Cut Value: {cut_value}\"")""",0
"""import networkx as nx\n\ndef maximum_cut_randomized(G):\n    # Use a randomized approach to solve Maximum Cut\n    import random\n    partition_A = set(random.sample(G.nodes(), len(G.nodes()) // 2))\n    partition_B = set(G.nodes()) - partition_A\n    cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 3), (3, 4), (4, 0)])\ncut_value = maximum_cut_randomized(G)\nprint(f\""Maximum Cut Value: {cut_value}\"")""",0
"""# Python code\nimport networkx as nx\n\ndef independent_set(G):\n    # Find the independent set of the graph\n    independent_set = set()\n    for node in G.nodes():\n        # Add the node to independent set if none of its neighbors are in the set\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nresult = independent_set(G)\nprint(f\""Independent Set: {result}\"")""",0
"""import networkx as nx\n\ndef independent_set_greedy(G):\n    # Greedy approach to find maximal independent set\n    independent_set = set()\n    for node in sorted(G.nodes(), key=lambda n: G.degree(n)):\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 4), (4, 3)])\nresult = independent_set_greedy(G)\nprint(f\""Maximal Independent Set: {result}\"")""",1
"# Python code\nimport networkx as nx\n\ndef independent_set(G):\n    independent_set = set()\n    for node in G.nodes():\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nresult = independent_set(G)\nprint(f\""Independent Set: {result}\"")",0
"""# Python code\nimport networkx as nx\n\ndef max_cut_greedy_algorithm(graph):\n    # Solve maximum cut using a greedy algorithm\n    set_A = set()\n    set_B = set(graph.nodes())\n    for vertex in graph.nodes():\n        # Assign vertex to partition based on neighbors\n        if sum(1 for neighbor in graph.neighbors(vertex) if neighbor in set_A) > sum(1 for neighbor in graph.neighbors(vertex) if neighbor in set_B):\n            set_B.add(vertex)\n        else:\n            set_A.add(vertex)\n    # Calculate the cut value\n    cut_val = sum(1 for u, v in graph.edges() if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n    return cut_val\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 3), (3, 4), (4, 0)])\ncut_value = max_cut_greedy_algorithm(G)\nprint(f\""Maximum Cut Value: {cut_value}\"")""",0
"""import networkx as nx\nimport random\n\ndef randomized_maximum_cut_solution(G):\n    # Randomized method to find maximum cut\n    part_A = set(random.sample(G.nodes(), len(G.nodes()) // 2))\n    part_B = set(G.nodes()) - part_A\n    cut_value = sum(1 for u, v in G.edges() if (u in part_A and v in part_B) or (u in part_B and v in part_A))\n    return cut_value\n\n# Create graph\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncut_value = randomized_maximum_cut_solution(G)\nprint(f\""Maximum Cut Value: {cut_value}\"")""",0
"""# Python code\nimport networkx as nx\n\ndef find_independent_set(G):\n    # Heuristic approach to find maximal independent set\n    ind_set = set()\n    for v in sorted(G.nodes(), key=lambda x: G.degree(x)):\n        # Add node to independent set if none of its neighbors are in the set\n        if all(neighbor not in ind_set for neighbor in G.neighbors(v)):\n            ind_set.add(v)\n    return ind_set\n\n# Example graph\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 4), (4, 3)])\nindependent_set = find_independent_set(G)\nprint(f\""Maximal Independent Set: {independent_set}\"")""",1
"""# Python code\nimport networkx as nx\n\ndef independent_set_randomized(graph):\n    # Randomized approach to find maximal independent set\n    import random\n    i_set = set()\n    remaining_nodes = list(graph.nodes())\n    random.shuffle(remaining_nodes)\n    for node in remaining_nodes:\n        if all(neighbor not in i_set for neighbor in graph.neighbors(node)):\n            i_set.add(node)\n    return i_set\n\n# Create graph\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nresult = independent_set_randomized(G)\nprint(f\""Independent Set: {result}\"")""",1
"""import networkx as nx\nfrom itertools import permutations\n\ndef tsp_brute_force(graph):\n    # Brute-force solution for TSP\n    nodes = list(graph.nodes())\n    min_cost = float('inf')\n    best_route = None\n    for route in permutations(nodes):\n        cost = sum(graph[route[i]][route[i+1]]['weight'] for i in range(len(route) - 1)) + graph[route[-1]][route[0]]['weight']\n        if cost < min_cost:\n            min_cost = cost\n            best_route = route\n    return min_cost, best_route\n\n# Create a graph with weighted edges\nG = nx.Graph()\nG.add_weighted_edges_from([(0, 1, 10), (1, 2, 15), (2, 3, 20), (3, 0, 25)])\nmin_cost, route = tsp_brute_force(G)",2
"""# Python code\nimport networkx as nx\nfrom itertools import permutations\n\ndef traveling_salesman_dp(graph):\n    # Solve TSP using Dynamic Programming\n    nodes = list(graph.nodes())\n    n = len(nodes)\n    dp = [[None] * (1 << n) for _ in range(n)]\n    def tsp(pos, visited):\n        if visited == (1 << n) - 1:\n            return graph[pos][0]['weight'] if 0 in graph[pos] else float('inf')\n        if dp[pos][visited] is not None:\n            return dp[pos][visited]\n        ans = float('inf')\n        for city in range(n):\n            if visited & (1 << city) == 0 and city in graph[pos]:\n                ans = min(ans, graph[pos][city]['weight'] + tsp(city, visited | (1 << city)))\n        dp[pos][visited] = ans\n        return ans\n    return tsp(0, 1)\n\n# Example graph with weighted edges\nG = nx.Graph()\nG.add_weighted_edges_from([(0, 1, 12), (1, 2, 10), (2, 3, 8), (3, 0, 15)])\nmin_cost = traveling_salesman_dp(G)",2
"""import networkx as nx\nimport random\n\ndef tsp_randomized_approximation(graph):\n    # Randomized approximation algorithm for TSP\n    nodes = list(graph.nodes())\n    random.shuffle(nodes)\n    total_cost = 0\n    route = [nodes[0]]\n    for i in range(1, len(nodes)):\n        total_cost += graph[nodes[i - 1]][nodes[i]]['weight']\n        route.append(nodes[i])\n    total_cost += graph[route[-1]][route[0]]['weight']\n    return total_cost, route\n\n# Example graph with weighted edges\nG = nx.Graph()\nG.add_weighted_edges_from([(0, 1, 10), (1, 2, 20), (2, 3, 30), (3, 0, 40)])\ncost, route = tsp_randomized_approximation(G)""",2
"""def maximum_cut_brute_force(edges, n):\n    best_cut_value = 0\n    best_partition = None\n    for i in range(1 << n):\n        set_A = {j for j in range(n) if i & (1 << j)}\n        set_B = set(range(n)) - set_A\n        cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n        if cut_value > best_cut_value:\n            best_cut_value = cut_value\n            best_partition = (set_A, set_B)\n    return best_cut_value, best_partition\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, partition = maximum_cut_brute_force(edges, 4)""",0
"""def maximum_cut_greedy(edges, n):\n    set_A = set()\n    set_B = set(range(n))\n    for node in range(n):\n        if sum(1 for u, v in edges if u == node and v in set_A) > sum(1 for u, v in edges if u == node and v in set_B):\n            set_B.add(node)\n        else:\n            set_A.add(node)\n    cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n    return cut_value, set_A, set_B\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, part_A, part_B = maximum_cut_greedy(edges, 4)""",0
"""def maximal_independent_set(n, edges):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set = maximal_independent_set(4, edges)\nprint(f\""Maximal Independent Set: {independent_set}\"")""",1
"""def independent_set_greedy(n, edges):\n    independent_set = set()\n    sorted_nodes = sorted(range(n), key=lambda node: sum(1 for u, v in edges if u == node or v == node))\n    for node in sorted_nodes:\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set = independent_set_greedy(4, edges)""",1
"""def tsp_brute_force(cost_matrix):\n    from itertools import permutations\n    n = len(cost_matrix)\n    min_cost = float('inf')\n    best_route = None\n    for route in permutations(range(n)):\n        cost = sum(cost_matrix[route[i]][route[i+1]] for i in range(n-1)) + cost_matrix[route[-1]][route[0]]\n        if cost < min_cost:\n            min_cost = cost\n            best_route = route\n    return min_cost, best_route\n\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\nmin_cost, best_route = tsp_brute_force(cost_matrix)""",2
"""def maximum_cut_heuristic(n, edges):\n    # Heuristic approach for Maximum Cut\n    set_A, set_B = set(), set(range(n))\n    while set_B:\n        node = set_B.pop()\n        if sum(1 for u, v in edges if u == node and v in set_A) > sum(1 for u, v in edges if u == node and v in set_B):\n            set_A.add(node)\n        else:\n            set_B.add(node)\n    cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n    return cut_value, set_A, set_B\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, set_A, set_B = maximum_cut_heuristic(4, edges)""",0
"""def maximum_cut_random(n, edges):\n    import random\n    # Randomized approach for Maximum Cut\n    set_A, set_B = set(), set()\n    for i in range(n):\n        if random.random() > 0.5:\n            set_A.add(i)\n        else:\n            set_B.add(i)\n    cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n    return cut_value, set_A, set_B\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, set_A, set_B = maximum_cut_random(4, edges)""",0
"""def maximal_independent_set_backtrack(n, edges):\n    # Backtracking approach to find the Maximal Independent Set\n    best_set = set()\n    def backtrack(node, independent_set):\n        nonlocal best_set\n        if node == n:\n            if len(independent_set) > len(best_set):\n                best_set = independent_set.copy()\n            return\n        # Option 1: Include node\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n            backtrack(node + 1, independent_set)\n            independent_set.remove(node)\n        # Option 2: Exclude node\n        backtrack(node + 1, independent_set)\n    backtrack(0, set())\n    return best_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set = maximal_independent_set_backtrack(4, edges)\nprint(f\""Maximal Independent Set: {independent_set}\"")""",1
"""def maximal_independent_set_approx(n, edges):\n    # Approximation algorithm for MIS\n    independent_set = set()\n    nodes = set(range(n))\n    while nodes:\n        node = nodes.pop()\n        independent_set.add(node)\n        neighbors = {v for u, v in edges if u == node}\n        nodes -= neighbors\n    return independent_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set = maximal_independent_set_approx(4, edges)\nprint(f\""Maximal Independent Set: {independent_set}\"")""",1
"def tsp_nearest_neighbor(cost_matrix):\n    # Nearest Neighbor heuristic for TSP\n    n = len(cost_matrix)\n    visited = [False] * n\n    route = [0]\n    visited[0] = True\n    total_cost = 0\n    current = 0\n    for _ in range(n - 1):\n        next_city = min((city for city in range(n) if not visited[city]), key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        visited[next_city] = True\n        current = next_city\n    total_cost += cost_matrix[current][0]\n    return total_cost, route\n\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = tsp_nearest_neighbor(cost_matrix)",2
"def tsp_simulated_annealing(cost_matrix):\n    import random, math\n    # Simulated Annealing for TSP\n    n = len(cost_matrix)\n    current_route = list(range(n))\n    random.shuffle(current_route)\n    current_cost = sum(cost_matrix[current_route[i]][current_route[i+1]] for i in range(n-1)) + cost_matrix[current_route[-1]][current_route[0]]\n    temp = 1000\n    cooling_rate = 0.95\n    while temp > 1:\n        new_route = current_route[:]\n        i, j = random.sample(range(n), 2)\n        new_route[i], new_route[j] = new_route[j], new_route[i]\n        new_cost = sum(cost_matrix[new_route[i]][new_route[i+1]] for i in range(n-1)) + cost_matrix[new_route[-1]][new_route[0]]\n        if new_cost < current_cost or math.exp((current_cost - new_cost) / temp) > random.random():\n            current_route = new_route\n            current_cost = new_cost\n        temp *= cooling_rate\n    return current_cost, current_route\n\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = tsp_simulated_annealing(cost_matrix)",2
"def tsp_greedy(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(n))\n    route = [0]\n    unvisited.remove(0)\n    total_cost = 0\n    current_city = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current_city][city])\n        total_cost += cost_matrix[current_city][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current_city = next_city\n    total_cost += cost_matrix[route[-1]][route[0]]\n    return total_cost, route\n\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = tsp_greedy(cost_matrix)",2
"def maximum_cut_quick(edges, n):\n    set_A, set_B = set(), set(range(n))\n    for u, v in edges:\n        if len(set_A) < len(set_B):\n            set_A.add(u)\n        else:\n            set_B.add(v)\n    return sum(1 for u, v in edges if (u in set_A and v in set_B)), set_A, set_B",0
"def maximum_cut_simple(n, edges):\n    set_A, set_B = set(), set()\n    for node in range(n):\n        if node % 2 == 0:\n            set_A.add(node)\n        else:\n            set_B.add(node)\n    return sum(1 for u, v in edges if (u in set_A and v in set_B)), set_A, set_B",0
"def independent_set_quick(n, edges):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set",1
"def independent_set_random(n, edges):\n    from random import shuffle\n    nodes = list(range(n))\n    shuffle(nodes)\n    independent_set = set()\n    for node in nodes:\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set",1
"def tsp_approx(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route",2
"def tsp_greedy_short(cost_matrix):\n    n = len(cost_matrix)\n    route, total_cost = [0], 0\n    current = 0\n    for _ in range(1, n):\n        next_city = min(range(n), key=lambda city: cost_matrix[current][city] if city not in route else float('inf'))\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route",2
"def max_cut_random(edges, n):\n    import random\n    A, B = set(), set()\n    for i in range(n):\n        if random.random() > 0.5:\n            A.add(i)\n        else:\n            B.add(i)\n    return sum(1 for u, v in edges if (u in A and v in B) or (u in B and v in A)), A, B",0
"def max_cut_with_weights(edges, n):\n    A, B = set(), set(range(n))\n    cut_value = 0\n    for u, v, w in edges:\n        if (u in A and v in B) or (u in B and v in A):\n            cut_value += w\n    return cut_value, A, B",0
"def max_cut_bitmask(edges, n):\n    best_cut, best_partition = 0, None\n    for i in range(1 << n):\n        A = {j for j in range(n) if i & (1 << j)}\n        B = set(range(n)) - A\n        cut_value = sum(1 for u, v in edges if (u in A and v in B) or (u in B and v in A))\n        if cut_value > best_cut:\n            best_cut, best_partition = cut_value, (A, B)\n    return best_cut, best_partition",0
"def max_cut_alternate_assignment(edges, n):\n    A, B = set(), set()\n    for i in range(n):\n        if i % 2 == 0:\n            A.add(i)\n        else:\n            B.add(i)\n    cut_value = sum(1 for u, v in edges if (u in A and v in B) or (u in B and v in A))\n    return cut_value, A, B",0
"def max_cut_nearest_neighbor(edges, n):\n    A, B = {0}, set(range(1, n))\n    for u, v in edges:\n        if u in A and v in B:\n            B.remove(v)\n            A.add(v)\n        elif u in B and v in A:\n            A.remove(v)\n            B.add(v)\n    return sum(1 for u, v in edges if (u in A and v in B) or (u in B and v in A)), A, B",0
"def independent_set_random(n, edges):\n    from random import shuffle\n    nodes = list(range(n))\n    shuffle(nodes)\n    independent_set = set()\n    for node in nodes:\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set",1
"def independent_set_backtracking(n, edges):\n    def is_valid(independent_set, node):\n        return all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v])\n    def backtrack(node, independent_set):\n        if node == n:\n            return independent_set\n        if is_valid(independent_set, node):\n            new_set = independent_set.copy()\n            new_set.add(node)\n            return backtrack(node + 1, new_set)\n        return backtrack(node + 1, independent_set)\n    return backtrack(0, set())",1
"def independent_set_degree_heuristic(n, edges):\n    degree = {i: sum(1 for u, v in edges if u == i or v == i) for i in range(n)}\n    sorted_nodes = sorted(range(n), key=lambda x: degree[x])\n    independent_set = set()\n    for node in sorted_nodes:\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set",1
"def independent_set_greedy(n, edges):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set",1
"def independent_set_greedy_weighted(n, edges, weights):\n    independent_set = set()\n    for node in sorted(range(n), key=lambda x: weights[x]):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set",1
"def tsp_dynamic_programming(cost_matrix):\n    n = len(cost_matrix)\n    dp = [[float('inf')] * (1 << n) for _ in range(n)]\n    dp[0][1] = 0\n    for mask in range(1 << n):\n        for u in range(n):\n            if not (mask & (1 << u)):\n                continue\n            for v in range(n):\n                if mask & (1 << v):\n                    dp[v][mask] = min(dp[v][mask], dp[u][mask ^ (1 << v)] + cost_matrix[u][v])\n    return min(dp[i][(1 << n) - 1] + cost_matrix[i][0] for i in range(1, n))",2
"def tsp_greedy(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route",2
"def tsp_nearest_neighbor(cost_matrix):\n    n = len(cost_matrix)\n    visited = [False] * n\n    route = [0]\n    visited[0] = True\n    total_cost = 0\n    current = 0\n    for _ in range(n - 1):\n        next_city = min((city for city in range(n) if not visited[city]), key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        visited[next_city] = True\n        current = next_city\n    total_cost += cost_matrix[current][0]\n    return total_cost, route",2
"def tsp_simulated_annealing(cost_matrix):\n    import random, math\n    n = len(cost_matrix)\n    current_route = list(range(n))\n    random.shuffle(current_route)\n    current_cost = sum(cost_matrix[current_route[i]][current_route[i+1]] for i in range(n-1)) + cost_matrix[current_route[-1]][current_route[0]]\n    temp = 1000\n    cooling_rate = 0.95\n    while temp > 1:\n        new_route = current_route[:]\n        i, j = random.sample(range(n), 2)\n        new_route[i], new_route[j] = new_route[j], new_route[i]\n        new_cost = sum(cost_matrix[new_route[i]][new_route[i+1]] for i in range(n-1)) + cost_matrix[new_route[-1]][new_route[0]]\n        if new_cost < current_cost or math.exp((current_cost - new_cost) / temp) > random.random():\n            current_route = new_route\n            current_cost = new_cost\n        temp *= cooling_rate\n    return current_cost, current_route",2
"def tsp_approx(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route",2
"import networkx as nx\n\ndef maximum_cut_greedy_networkx(G):\n    set_A, set_B = set(), set(G.nodes)\n    for node in G.nodes:\n        if sum(1 for neighbor in G.neighbors(node) if neighbor in set_A) > sum(1 for neighbor in G.neighbors(node) if neighbor in set_B):\n            set_B.add(node)\n        else:\n            set_A.add(node)\n    cut_value = sum(1 for u, v in G.edges if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n    return cut_value, set_A, set_B\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nmaximum_cut_greedy_networkx(G)",0
"def maximum_cut_randomized(edges, n):\n    import random\n    set_A, set_B = set(), set()\n    for i in range(n):\n        if random.random() > 0.5:\n            set_A.add(i)\n        else:\n            set_B.add(i)\n    return sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in B and v in A)), set_A, set_B\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nmaximum_cut_randomized(edges, 4)",0
"def maximum_cut_bitmask(edges, n):\n    best_cut, best_partition = 0, None\n    for mask in range(1 << n):\n        set_A = {i for i in range(n) if mask & (1 << i)}\n        set_B = set(range(n)) - set_A\n        cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in B and v in A))\n        if cut_value > best_cut:\n            best_cut, best_partition = cut_value, (set_A, set_B)\n    return best_cut, best_partition",0
"def maximum_cut_degree_based(n, edges):\n    degree = {i: sum(1 for u, v in edges if u == i or v == i) for i in range(n)}\n    A, B = set(), set()\n    for node in sorted(range(n), key=lambda x: degree[x], reverse=True):\n        if len(A) <= len(B):\n            A.add(node)\n        else:\n            B.add(node)\n    return sum(1 for u, v in edges if (u in A and v in B) or (u in B and v in A)), A, B",0
"import networkx as nx\n\ndef maximum_cut_brute_force_networkx(G):\n    from itertools import combinations\n    best_cut = 0\n    best_partition = None\n    for cut in combinations(G.nodes, len(G)//2):\n        A = set(cut)\n        B = set(G.nodes) - A\n        cut_value = sum(1 for u, v in G.edges if (u in A and v in B) or (u in B and v in A))\n        if cut_value > best_cut:\n            best_cut = cut_value\n            best_partition = A, B\n    return best_cut, best_partition\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nmaximum_cut_brute_force_networkx(G)",0
"import networkx as nx\n\ndef independent_set_greedy_networkx(G):\n    independent_set = set()\n    for node in G.nodes:\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nindependent_set_greedy_networkx(G)",1
"def independent_set_greedy(edges, n):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set_greedy(edges, 4)",1
"def independent_set_random(n, edges):\n    from random import shuffle\n    nodes = list(range(n))\n    shuffle(nodes)\n    independent_set = set()\n    for node in nodes:\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set_random(n, edges)",1
"import networkx as nx\n\ndef independent_set_backtracking_networkx(G):\n    def is_valid_set(independent_set, node):\n        return all(neighbor not in independent_set for neighbor in G.neighbors(node))\n    def backtrack(node, independent_set):\n        if node == len(G):\n            return independent_set\n        if is_valid_set(independent_set, node):\n            new_set = independent_set.copy()\n            new_set.add(node)\n            return backtrack(node + 1, new_set)\n        return backtrack(node + 1, independent_set)\n    return backtrack(0, set())\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nindependent_set_backtracking_networkx(G)",1
"def independent_set_degree_heuristic(n, edges):\n    degree = {i: sum(1 for u, v in edges if u == i or v == i) for i in range(n)}\n    independent_set = set()\n    for node in sorted(range(n), key=lambda x: degree[x]):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set_degree_heuristic(n, edges)",1
"import networkx as nx\n\ndef tsp_brute_force_networkx(G):\n    from itertools import permutations\n    best_cost = float('inf')\n    best_route = None\n    for route in permutations(G.nodes):\n        cost = sum(G[route[i]][route[i+1]]['weight'] for i in range(len(route) - 1)) + G[route[-1]][route[0]]['weight']\n        if cost < best_cost:\n            best_cost = cost\n            best_route = route\n    return best_cost, best_route\n\nG = nx.Graph()\nG.add_weighted_edges_from([(0, 1, 10), (1, 2, 15), (2, 3, 20), (3, 0, 25)])\ntsp_brute_force_networkx(G)",2
"def tsp_greedy(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ntsp_greedy(cost_matrix)",2
"def tsp_simulated_annealing(cost_matrix):\n    import random, math\n    n = len(cost_matrix)\n    current_route = list(range(n))\n    random.shuffle(current_route)\n    current_cost = sum(cost_matrix[current_route[i]][current_route[i+1]] for i in range(n-1)) + cost_matrix[current_route[-1]][current_route[0]]\n    temp = 1000\n    cooling_rate = 0.95\n    while temp > 1:\n        new_route = current_route[:]\n        i, j = random.sample(range(n), 2)\n        new_route[i], new_route[j] = new_route[j], new_route[i]\n        new_cost = sum(cost_matrix[new_route[i]][new_route[i+1]] for i in range(n-1)) + cost_matrix[new_route[-1]][new_route[0]]\n        if new_cost < current_cost or math.exp((current_cost - new_cost) / temp) > random.random():\n            current_route = new_route\n            current_cost = new_cost\n        temp *= cooling_rate\n    return current_cost, current_route\n\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ntsp_simulated_annealing(cost_matrix)",2
"import networkx as nx\n\ndef tsp_nearest_neighbor_networkx(G):\n    visited = [False] * len(G)\n    route = [0]\n    visited[0] = True\n    total_cost = 0\n    current = 0\n    for _ in range(len(G) - 1):\n        next_city = min((city for city in range(len(G)) if not visited[city]), key=lambda city: G[current][city]['weight'])\n        total_cost += G[current][next_city]['weight']\n        route.append(next_city)\n        visited[next_city] = True\n        current = next_city\n    total_cost += G[route[-1]][route[0]]['weight']\n    return total_cost, route\n\nG = nx.Graph()\nG.add_weighted_edges_from([(0, 1, 10), (1, 2, 15), (2, 3, 20), (3, 0, 25)])\ntsp_nearest_neighbor_networkx(G)",2
"def clique_brute_force(n, edges):\n    from itertools import combinations\n    max_clique = []\n    for k in range(2, n+1):\n        for subset in combinations(range(n), k):\n            if all((u, v) in edges or (v, u) in edges for u in subset for v in subset if u != v):\n                if len(subset) > len(max_clique):\n                    max_clique = subset\n    return max_clique",3
"def clique_greedy(n, edges):\n    clique = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique",3
"import networkx as nx\n\ndef clique_networkx_brute_force(G):\n    from itertools import combinations\n    max_clique = []\n    nodes = list(G.nodes())\n    for k in range(2, len(nodes) + 1):\n        for subset in combinations(nodes, k):\n            if G.subgraph(subset).number_of_edges() == len(subset) * (len(subset) - 1) // 2:\n                if len(subset) > len(max_clique):\n                    max_clique = subset\n    return max_clique\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)])\nclique_networkx_brute_force(G)",3
"def clique_greedy_degree_heuristic(n, edges):\n    degree = {i: sum(1 for u, v in edges if u == i or v == i) for i in range(n)}\n    clique = set()\n    for node in sorted(range(n), key=lambda x: degree[x], reverse=True):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique",3
"def clique_randomized(n, edges):\n    import random\n    nodes = list(range(n))\n    random.shuffle(nodes)\n    clique = set()\n    for node in nodes:\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique",3
"import networkx as nx\n\ndef clique_networkx_greedy(G):\n    clique = set()\n    for node in G.nodes():\n        if all(neighbor in clique or (G.has_edge(node, neighbor)) for neighbor in G.neighbors(node)):\n            clique.add(node)\n    return clique\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)])\nclique_networkx_greedy(G)",3
"def clique_bitmask(n, edges):\n    max_clique = []\n    for mask in range(1 << n):\n        subset = [i for i in range(n) if mask & (1 << i)]\n        if all((u, v) in edges or (v, u) in edges for u in subset for v in subset if u != v):\n            if len(subset) > len(max_clique):\n                max_clique = subset\n    return max_clique",3
"def clique_backtracking(n, edges):\n    def is_clique(nodes):\n        return all((u, v) in edges or (v, u) in edges for u in nodes for v in nodes if u != v)\n    def backtrack(node, current_clique):\n        if node == n:\n            return current_clique\n        if is_clique(current_clique + [node]):\n            with_node = backtrack(node + 1, current_clique + [node])\n            without_node = backtrack(node + 1, current_clique)\n            return max(with_node, without_node, key=len)\n        return backtrack(node + 1, current_clique)\n    return backtrack(0, [])",3
"import networkx as nx\n\ndef clique_networkx_backtracking(G):\n    def is_clique(nodes):\n        return all(G.has_edge(u, v) for u in nodes for v in nodes if u != v)\n    def backtrack(node, current_clique):\n        if node == len(G.nodes):\n            return current_clique\n        if is_clique(current_clique + [node]):\n            with_node = backtrack(node + 1, current_clique + [node])\n            without_node = backtrack(node + 1, current_clique)\n            return max(with_node, without_node, key=len)\n        return backtrack(node + 1, current_clique)\n    return backtrack(0, [])\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)])\nclique_networkx_backtracking(G)",3
"def clique_approximate(n, edges):\n    clique = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique",3
"def kcoloring_backtracking(n, edges, k):\n    def is_valid_coloring(node, color, colors):\n        return all(colors[neighbor] != color for u, v in edges if u == node for neighbor in [v])\n    def backtrack(node, colors):\n        if node == n:\n            return colors\n        for color in range(k):\n            if is_valid_coloring(node, color, colors):\n                colors[node] = color\n                result = backtrack(node + 1, colors)\n                if result is not None:\n                    return result\n                colors[node] = -1\n        return None\n    return backtrack(0, [-1] * n)\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_backtracking(4, edges, 3)",4
"import networkx as nx\n\ndef kcoloring_networkx_greedy(G, k):\n    colors = {}\n    for node in G.nodes():\n        available_colors = set(range(k)) - {colors[neighbor] for neighbor in G.neighbors(node) if neighbor in colors}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nkcoloring_networkx_greedy(G, 3)",4
"def kcoloring_random(n, edges, k):\n    import random\n    colors = [-1] * n\n    nodes = list(range(n))\n    random.shuffle(nodes)\n    for node in nodes:\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v] if colors[neighbor] != -1}\n        if available_colors:\n            colors[node] = random.choice(list(available_colors))\n    return colors\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_random(4, edges, 3)",4
"def kcoloring_greedy_degree_heuristic(n, edges, k):\n    degree = {i: sum(1 for u, v in edges if u == i or v == i) for i in range(n)}\n    colors = [-1] * n\n    for node in sorted(range(n), key=lambda x: degree[x], reverse=True):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_greedy_degree_heuristic(4, edges, 3)",4
"import networkx as nx\n\ndef kcoloring_networkx_backtracking(G, k):\n    def is_valid_coloring(node, color, colors):\n        return all(colors[neighbor] != color for neighbor in G.neighbors(node))\n    def backtrack(node, colors):\n        if node == len(G.nodes):\n            return colors\n        for color in range(k):\n            if is_valid_coloring(node, color, colors):\n                colors[node] = color\n                result = backtrack(node + 1, colors)\n                if result is not None:\n                    return result\n                colors[node] = -1\n        return None\n    return backtrack(0, [-1] * len(G.nodes))\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nkcoloring_networkx_backtracking(G, 3)",4
"def kcoloring_min_conflict(n, edges, k, max_steps=1000):\n    import random\n    colors = [random.choice(range(k)) for _ in range(n)]\n    def count_conflicts(node):\n        return sum(1 for u, v in edges if u == node and colors[v] == colors[u])\n    for _ in range(max_steps):\n        conflicted = [node for node in range(n) if count_conflicts(node) > 0]\n        if not conflicted:\n            return colors\n        node = random.choice(conflicted)\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = random.choice(list(available_colors))\n    return None\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_min_conflict(4, edges, 3)",4
"import networkx as nx\n\ndef kcoloring_networkx_greedy_degree(G, k):\n    degree = {i: len(list(G.neighbors(i))) for i in G.nodes}\n    colors = {}\n    for node in sorted(G.nodes(), key=lambda x: degree[x], reverse=True):\n        available_colors = set(range(k)) - {colors[neighbor] for neighbor in G.neighbors(node) if neighbor in colors}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nkcoloring_networkx_greedy_degree(G, 3)",4
"def kcoloring_sequential(n, edges, k):\n    colors = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_sequential(4, edges, 3)",4
"import networkx as nx\n\ndef kcoloring_networkx_min_conflict(G, k):\n    import random\n    colors = {node: random.choice(range(k)) for node in G.nodes()}\n    def count_conflicts(node):\n        return sum(1 for neighbor in G.neighbors(node) if colors[neighbor] == colors[node])\n    for _ in range(1000):\n        conflicted = [node for node in G.nodes() if count_conflicts(node) > 0]\n        if not conflicted:\n            return colors\n        node = random.choice(conflicted)\n        available_colors = set(range(k)) - {colors[neighbor] for neighbor in G.neighbors(node)}\n        if available_colors:\n            colors[node] = random.choice(list(available_colors))\n    return None\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nkcoloring_networkx_min_conflict(G, 3)",4
"def kcoloring_dfs(n, edges, k):\n    def dfs(node, colors):\n        if node == n:\n            return colors\n        for color in range(k):\n            if all(colors[neighbor] != color for u, v in edges if u == node for neighbor in [v]):\n                colors[node] = color\n                result = dfs(node + 1, colors)\n                if result:\n                    return result\n                colors[node] = -1\n        return None\n    return dfs(0, [-1] * n)\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_dfs(4, edges, 3)",4
"import networkx as nx\n\ndef kcoloring_networkx_dfs(G, k):\n    def dfs(node, colors):\n        if node == len(G.nodes):\n            return colors\n        for color in range(k):\n            if all(colors[neighbor] != color for neighbor in G.neighbors(node)):\n                colors[node] = color\n                result = dfs(node + 1, colors)\n                if result:\n                    return result\n                colors[node] = -1\n        return None\n    return dfs(0, [-1] * len(G.nodes))\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nkcoloring_networkx_dfs(G, 3)",4